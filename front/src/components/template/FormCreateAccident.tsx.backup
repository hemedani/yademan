"use client";

import "leaflet/dist/leaflet.css";
import React from "react";
import type { Marker as LeafletMarker } from "leaflet";
import { useForm, SubmitHandler, useFieldArray } from "react-hook-form";
import { useRouter } from "next/navigation";
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useState, useEffect } from "react";
import dynamic from "next/dynamic";
import { LatLngExpression } from "leaflet";
import { ToastNotify } from "@/utils/helper";
import MyInput from "../atoms/MyInput";
import MyDateInput from "../atoms/MyDateInput";
import MyAsyncMultiSelect from "../atoms/MyAsyncMultiSelect";
import { add } from "@/app/actions/accident/add";
import { gets as getProvinces } from "@/app/actions/province/gets";
import { gets as getCities } from "@/app/actions/city/gets";
import { gets as getCityZones } from "@/app/actions/city_zone/gets";
import { gets as getTrafficZones } from "@/app/actions/traffic_zone/gets";
import { gets as getRoads } from "@/app/actions/road/gets";
import { gets as getRoadDefects } from "@/app/actions/road_defect/gets";
import { gets as getRoadRepairTypes } from "@/app/actions/road_repair_type/gets";
import { gets as getRoadSituations } from "@/app/actions/road_situation/gets";
import { gets as getRoadSurfaceConditions } from "@/app/actions/road_surface_condition/gets";
import { gets as getPositions } from "@/app/actions/position/gets";
import { gets as getTypes } from "@/app/actions/type/gets";
import { gets as getAirStatuses } from "@/app/actions/air_status/gets";
import { gets as getLightStatuses } from "@/app/actions/light_status/gets";
import { gets as getShoulderStatuses } from "@/app/actions/shoulder_status/gets";
import { gets as getAreaUsages } from "@/app/actions/area_usage/gets";
import { gets as getCollisionTypes } from "@/app/actions/collision_type/gets";
import { gets as getEquipmentDamages } from "@/app/actions/equipment_damage/gets";
import { gets as getRulingTypes } from "@/app/actions/ruling_type/gets";
import { gets as getHumanReasons } from "@/app/actions/human_reason/gets";
import { gets as getVehicleReasons } from "@/app/actions/vehicle_reason/gets";
import { gets as getColors } from "@/app/actions/color/gets";
import { gets as getPlaqueTypes } from "@/app/actions/plaque_type/gets";
import { gets as getPlaqueUsages } from "@/app/actions/plaque_usage/gets";
import { gets as getLicenceTypes } from "@/app/actions/licence_type/gets";
import { gets as getInsuranceCos } from "@/app/actions/insurance_co/gets";
import { gets as getBodyInsuranceCos } from "@/app/actions/body_insurance_co/gets";
import { gets as getFaultStatuses } from "@/app/actions/fault_status/gets";

import { gets as getMotionDirections } from "@/app/actions/motion_direction/gets";
import { gets as getSystems } from "@/app/actions/system/gets";
import { gets as getSystemTypes } from "@/app/actions/system_type/gets";

// Dynamic imports for map components
const MapContainer = dynamic(
  () => import("react-leaflet").then((mod) => mod.MapContainer),
  { ssr: false },
);

const TileLayer = dynamic(
  () => import("react-leaflet").then((mod) => mod.TileLayer),
  { ssr: false },
);

// Draggable marker component
const DraggableMarker = dynamic(
  () =>
    import("react-leaflet").then((mod) => {
      const { Marker } = mod;
      return function DraggableMarkerComponent({
        position,
        onMove,
      }: {
        position: [number, number];
        onMove: (lat: number, lng: number) => void;
      }) {
        const markerRef = React.useRef<LeafletMarker>(null);

        const eventHandlers = React.useMemo(
          () => ({
            dragend() {
              const marker = markerRef.current;
              if (marker != null) {
                const { lat, lng } = marker.getLatLng();
                onMove(lat, lng);
              }
            },
          }),
          [onMove],
        );

        return (
          <Marker
            draggable={true}
            eventHandlers={eventHandlers}
            position={position}
            ref={markerRef}
          />
        );
      };
    }),
  { ssr: false },
);

// Single select component for location fields
const MySingleSelect = dynamic(
  () =>
    import("react-select/async").then((mod) => {
      const AsyncSelect = mod.default;
      return function MySingleSelectComponent({
        name,
        label,
        loadOptions,
        setValue,
        defaultOptions = true,
        errMsg,
        placeholder,
        onSelectionChange,
      }: {
        name: string;
        label: string;
        loadOptions: (
          inputValue: string,
        ) => Promise<{ value: string; label: string }[]>;
        setValue: (name: string, value: string) => void;
        defaultOptions?: boolean;
        errMsg?: string;
        placeholder?: string;
        onSelectionChange?: (name: string, data: { _id: string; name: string } | null) => void;
      }) {
        return (
          <div className="flex flex-col gap-2">
            <label className="text-sm font-medium text-slate-700 text-right">
              {label}
            </label>
            <AsyncSelect
              cacheOptions
              defaultOptions={defaultOptions}
              loadOptions={loadOptions}
              onChange={(newVal: { value: string; label: string } | null) => {
                setValue(name, newVal?.value || "");
                if (onSelectionChange) {
                  onSelectionChange(name, newVal ? { _id: newVal.value, name: newVal.label } : null);
                }
              }}
              placeholder={placeholder || `${label} را انتخاب کنید`}
              noOptionsMessage={() => "گزینه‌ای یافت نشد"}
              loadingMessage={() => "در حال بارگذاری..."}
              isClearable
              isRtl
              styles={{
                control: (provided: any) => ({
                  ...provided,
                  minHeight: "48px",
                  borderRadius: "12px",
                  borderColor: errMsg ? "#ef4444" : "#cbd5e1",
                  direction: "rtl",
                }),
                option: (provided: any) => ({
                  ...provided,
                  direction: "rtl",
                  textAlign: "right",
                }),
                singleValue: (provided: any) => ({
                  ...provided,
                  direction: "rtl",
                }),
              }}
            />
            {errMsg && (
              <span className="text-red-500 text-xs font-medium text-right mt-1">
                {errMsg}
              </span>
            )}
          </div>
        );
      };
    }),
  { ssr: false },
);

// Validation schema
const AccidentCreateSchema = z.object({
  seri: z.coerce.number().min(1, "شماره سری الزامی است"),
  serial: z.coerce.number().min(1, "شماره سریال الزامی است"),
  date_of_accident: z.string().min(1, "تاریخ حادثه الزامی است"),
  completion_date: z.string().min(1, "تاریخ تکمیل الزامی است"),
  dead_count: z.coerce.number().min(0, "تعداد کشته نمی‌تواند منفی باشد"),
  injured_count: z.coerce.number().min(0, "تعداد مجروح نمی‌تواند منفی باشد"),
  news_number: z.coerce.number().min(1, "شماره خبر الزامی است"),
  officer: z.string().min(1, "نام افسر الزامی است"),
  has_witness: z.boolean(),
  latitude: z
    .union([z.coerce.number(), z.string()])
    .transform((val) => {
      if (typeof val === "string") {
        const persianNumbers = [
          "۰",
          "۱",
          "۲",
          "۳",
          "۴",
          "۵",
          "۶",
          "۷",
          "۸",
          "۹",
        ];
        const englishNumbers = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
        ];
        let converted = val;
        persianNumbers.forEach((persian, index) => {
          converted = converted.replace(new RegExp(persian, "g"), englishNumbers[index]);
        });
        return parseFloat(converted);
      }
      return val;
    })
    .refine((val) => !isNaN(val), "عرض جغرافیایی باید عدد باشد")
    .refine((val) => val >= -90 && val <= 90, "عرض جغرافیایی باید بین -90 تا 90 باشد"),
  longitude: z
    .union([z.coerce.number(), z.string()])
    .transform((val) => {
      if (typeof val === "string") {
        const persianNumbers = [
          "۰",
          "۱",
          "۲",
          "۳",
          "۴",
          "۵",
          "۶",
          "۷",
          "۸",
          "۹",
        ];
        const englishNumbers = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
        ];
        let converted = val;
        persianNumbers.forEach((persian, index) => {
          converted = converted.replace(new RegExp(persian, "g"), englishNumbers[index]);
        });
        return parseFloat(converted);
      }
      return val;
    })
    .refine((val) => !isNaN(val), "طول جغرافیایی باید عدد باشد")
    .refine((val) => val >= -180 && val <= 180, "طول جغرافیایی باید بین -180 تا 180 باشد"),
  province: z.string().optional(),
  city: z.string().optional(),
  road: z.string().optional(),
  traffic_zone: z.string().optional(),
  city_zone: z.string().optional(),
  type: z.string().optional(),
  position: z.string().optional(),
  ruling_type: z.string().optional(),
  light_status: z.string().optional(),
  collision_type: z.string().optional(),
  road_situation: z.string().optional(),
  road_repair_type: z.string().optional(),
  shoulder_status: z.string().optional(),
  area_usages: z.array(z.string()).optional(),
  air_statuses: z.array(z.string()).optional(),
  road_defects: z.array(z.string()).optional(),
  human_reasons: z.array(z.string()).optional(),
  vehicle_reasons: z.array(z.string()).optional(),
  equipment_damages: z.array(z.string()).optional(),
  road_surface_conditions: z.array(z.string()).optional(),
  vehicle_dtos: z
    .array(
      z.object({
        color: z.string().optional(),
        system: z.string().optional(),
        plaque_type: z.string().optional(),
        plaque_usage: z.string().optional(),
        system_type: z.string().optional(),
        fault_status: z.string().optional(),
        insurance_co: z.string().optional(),
        insurance_no: z.string().optional(),
        insurance_date: z.string().optional(),
        body_insurance_co: z.string().optional(),
        body_insurance_no: z.string().optional(),
        body_insurance_date: z.string().optional(),
        motion_direction: z.string().optional(),
        print_number: z.string().optional(),
        insurance_warranty_limit: z.coerce.number().optional(),
        damage_section_other: z.string().optional(),
        plaque_no: z.array(z.string()).optional(),
        plaque_serial: z.array(z.string()).optional(),
        max_damage_sections: z.array(z.string()).optional(),
        driver: z.object({
          first_name: z.string().min(1, "نام راننده الزامی است"),
          last_name: z.string().min(1, "نام خانوادگی راننده الزامی است"),
          national_code: z.string().min(1, "کد ملی راننده الزامی است"),
          sex: z.enum(["Male", "Female", "Other"]),
          licence_type: z.string().optional(),
          licence_number: z.string().optional(),
          injury_type: z.string().optional(),
          total_reason: z.string().optional(),
        }),
        passenger_dtos: z
          .array(
            z.object({
              first_name: z.string().min(1, "نام مسافر الزامی است"),
              last_name: z.string().min(1, "نام خانوادگی مسافر الزامی است"),
              national_code: z.string().min(1, "کد ملی مسافر الزامی است"),
              sex: z.enum(["Male", "Female", "Other"]),
              injury_type: z.string().optional(),
              fault_status: z.string().optional(),
              total_reason: z.string().optional(),
            }),
          )
          .optional(),
      }),
    )
    .optional(),
  pedestrian_dtos: z
    .array(
      z.object({
        first_name: z.string().min(1, "نام عابر پیاده الزامی است"),
        last_name: z.string().min(1, "نام خانوادگی عابر پیاده الزامی است"),
        national_code: z.string().min(1, "کد ملی عابر پیاده الزامی است"),
        sex: z.enum(["Male", "Female", "Other"]),
        injury_type: z.string().optional(),
        fault_status: z.string().optional(),
        total_reason: z.string().optional(),
      }),
    )
    .optional(),
});

type AccidentFormCreateSchemaType = z.infer<typeof AccidentCreateSchema>;

const FormCreateAccident = () => {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [markerPosition, setMarkerPosition] = useState<[number, number]>([
    31.304661792933331,
    48.649177551269495,
  ]);

  // Store full object data for vehicle/pedestrian fields
  const [fieldData, setFieldData] = useState<Record<string, { _id: string; name: string }>>({});

  const {
    register,
    handleSubmit,
    setValue,
    watch,
    formState: { errors },
  } = useForm<AccidentFormCreateSchemaType>({
    resolver: zodResolver(AccidentCreateSchema),
    defaultValues: {
      dead_count: 0,
      injured_count: 0,
      has_witness: false,
      latitude: 31.304661792933331,
      longitude: 48.649177551269495,
      vehicle_dtos: [],
      pedestrian_dtos: [],
    },
  });

  const {
    fields: vehicleFields,
    append: appendVehicle,
    remove: removeVehicle,
  } = useFieldArray({
    control,
    name: "vehicle_dtos",
  });

  const {
    fields: pedestrianFields,
    append: appendPedestrian,
    remove: removePedestrian,
  } = useFieldArray({
    control,
    name: "pedestrian_dtos",
  });

  // Handle field data changes
  const handleFieldDataChange = (fieldName: string, data: { _id: string; name: string } | null) => {
    setFieldData(prev => {
      if (data) {
        return { ...prev, [fieldName]: data };
      } else {
        const newData = { ...prev };
        delete newData[fieldName];
        return newData;
      }
    });
  };

  // Helper function to get object data from stored fieldData
  const getObjectData = (fieldName: string, fallbackId: string) => {
    const storedData = fieldData[fieldName];
    if (storedData) {
      return storedData;
    }
    // Fallback to just _id if no name is stored
    return fallbackId ? { _id: fallbackId } : undefined;
  };

  // Watch for position changes
  const latitudeValue = watch("latitude");
  const longitudeValue = watch("longitude");

  useEffect(() => {
    if (latitudeValue && longitudeValue) {
      setMarkerPosition([latitudeValue, longitudeValue]);
    }
  }, [latitudeValue, longitudeValue]);

  const handleMarkerMove = (lat: number, lng: number) => {
    setMarkerPosition([lat, lng]);
    setValue("latitude", lat);
    setValue("longitude", lng);
  };

  // Load options functions for single selects
  const loadProvinces = async (inputValue: string) => {
    try {
      const response = await getProvinces({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadCities = async (inputValue: string) => {
    try {
      const response = await getCities({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadCityZones = async (inputValue: string) => {
    try {
      const response = await getCityZones({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadTrafficZones = async (inputValue: string) => {
    try {
      const response = await getTrafficZones({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadRoads = async (inputValue: string) => {
    try {
      const response = await getRoads({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadTypes = async (inputValue: string) => {
    try {
      const response = await getTypes({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadPositions = async (inputValue: string) => {
    try {
      const response = await getPositions({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadRulingTypes = async (inputValue: string) => {
    try {
      const response = await getRulingTypes({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadLightStatuses = async (inputValue: string) => {
    try {
      const response = await getLightStatuses({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadShoulderStatuses = async (inputValue: string) => {
    try {
      const response = await getShoulderStatuses({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadCollisionTypes = async (inputValue: string) => {
    try {
      const response = await getCollisionTypes({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadRoadSituations = async (inputValue: string) => {
    try {
      const response = await getRoadSituations({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadRoadRepairTypes = async (inputValue: string) => {
    try {
      const response = await getRoadRepairTypes({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  // Load functions for multi-selects (arrays)
  const loadRoadDefects = async (inputValue: string) => {
    try {
      const response = await getRoadDefects({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadRoadSurfaceConditions = async (inputValue: string) => {
    try {
      const response = await getRoadSurfaceConditions({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadAirStatuses = async (inputValue: string) => {
    try {
      const response = await getAirStatuses({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadHumanReasons = async (inputValue: string) => {
    try {
      const response = await getHumanReasons({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadVehicleReasons = async (inputValue: string) => {
    try {
      const response = await getVehicleReasons({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadEquipmentDamages = async (inputValue: string) => {
    try {
      const response = await getEquipmentDamages({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadAreaUsages = async (inputValue: string) => {
    try {
      const response = await getAreaUsages({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  // Load functions for vehicle/pedestrian fields
  const loadColors = async (inputValue: string) => {
    try {
      const response = await getColors({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadSystems = async (inputValue: string) => {
    try {
      const response = await getSystems({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
        ? response.body.map((item: { _id: string; name: string }) => ({
            value: item._id,
            label: item.name,
          }))
        : [];
    } catch {
      return [];
    }
  };

  const loadPlaqueTypes = async (inputValue: string) => {
    try {
      const response = await getPlaqueTypes({
        set: { name: inputValue, page: 1, limit: 50 },
        get: { _id: 1, name: 1 },
      });
      return response.success
